<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holo-Tulip Interface v3 - Advanced Mouse Control</title>
    <style>
        /* Cursor inicial */
        body { margin: 0; overflow: hidden; background-color: #050005; font-family: 'Consolas', monospace; cursor: crosshair; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 3;
            color: rgba(255, 100, 150, 0.9); pointer-events: none;
            user-select: none;
        }
        h1 { margin: 0; font-size: 1rem; letter-spacing: 2px; border-bottom: 1px solid rgba(255,0,100,0.5); padding-bottom: 5px; display: inline-block;}
        .status { font-size: 0.8rem; margin-top: 8px; }
        .instructions { font-size: 0.7rem; color: #aaa; margin-top: 6px; line-height: 1.4; }
        .key-action { color: #ff0055; font-weight: bold;}

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff0055; font-size: 1.2rem; text-shadow: 0 0 10px #ff0055;
            transition: opacity 0.5s;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading">GENERATING FLORA...</div>
    <div id="ui-layer">
        <h1>PROJECT: TULIP v3</h1>
        <div class="status" id="debug-state">STATE: DISPERSED</div>
        <div class="instructions">
            [MOUSE MOVE] Position<br>
            [<span class="key-action">L-CLICK</span> HOLD] Form Tulip<br>
            [<span class="key-action">R-CLICK</span> DRAG] Rotate Y-Axis<br>
            [<span class="key-action">SCROLL</span>] Zoom In/Out
        </div>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform float uExplosion; 
        attribute float aSize;
        attribute float aRandom;
        varying vec3 vPos;
        varying float vAlpha;

        void main() {
            vec3 pos = position;

            // --- LÓGICA DE DISPERSIÓN ---
            float noiseX = sin(uTime * 2.0 + aRandom * 10.0) * 2.0;
            float noiseY = cos(uTime * 1.5 + aRandom * 20.0) * 2.0;
            float noiseZ = sin(uTime * 2.5 + aRandom * 30.0) * 2.0;
            
            vec3 explosionDir = normalize(pos) * (20.0 + aRandom * 30.0);
            vec3 chaoticPos = pos + explosionDir + vec3(noiseX, noiseY, noiseZ);
            
            pos = mix(pos, chaoticPos, uExplosion);

            // Rotación suave interna extra para que las partículas siempre se muevan un poco
            float angle = uTime * 0.05; 
            float s = sin(angle); float c = cos(angle);
            float x = pos.x * c - pos.z * s;
            float z = pos.x * s + pos.z * c;
            pos.x = x; pos.z = z;

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            
            float sizeMod = 1.0 + uExplosion * 2.0; 
            gl_PointSize = (4.0 * aSize * sizeMod) * (60.0 / -mvPosition.z);
            
            vPos = position; 
            vAlpha = 1.0 - (uExplosion * 0.4);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float uExplosion;
        varying vec3 vPos;
        varying float vAlpha;
        
        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            if(dist > 0.5) discard;

            // --- COLOREADO TULIPÁN ---
            float height = smoothstep(-10.0, 20.0, vPos.y);
            vec3 darkPink = vec3(0.8, 0.0, 0.4); 
            vec3 lightPink = vec3(1.0, 0.6, 0.8); 
            vec3 white = vec3(1.0, 1.0, 1.0);     
            vec3 color = mix(darkPink, lightPink, height);
            color = mix(color, white, pow(height, 3.0)); 
            if(vPos.y < -8.0) { color = mix(color, vec3(0.0, 0.5, 0.2), 0.7); }

            float extraGlow = uExplosion * 0.15; 
            color += vec3(extraGlow);

            float softness = mix(1.5, 0.5, uExplosion);
            float strength = 1.0 - (dist * 2.0);
            strength = pow(max(0.0, strength), softness);

            gl_FragColor = vec4(color, strength * vAlpha * 0.9);
        }
    </script>

    <script>
        const config = {
            posLerp: 0.08,  
            baseZ: 0,
            zoomSpeed: 0.1,
            minZ: 20,
            maxZ: 150
        };

        // Estado inicial
        const state = {
            targetPos: new THREE.Vector3(0, 0, config.baseZ),
            currentPos: new THREE.Vector3(0, 0, config.baseZ),
            targetExplosion: 1.0, 
            currentExplosion: 1.0,
            manualRotationAdd: 0, // Acumulador para rotación con click derecho
            isRightDragging: false,
            lastMouseX: 0
        };

        const els = {
            loading: document.getElementById('loading'),
            debug: document.getElementById('debug-state')
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050005, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Posición inicial de la cámara (afectada por zoom)
        camera.position.set(0, 0, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Importante: permitir capturar eventos de rueda en el canvas
        document.body.appendChild(renderer.domElement);

        // --- GEOMETRÍA (Igual que antes) ---
        const geometry = new THREE.BufferGeometry();
        const count = 35000;
        const positions = [];
        const sizes = [];
        const randoms = [];

        for(let i=0; i<count; i++) {
            let u = Math.random(); let v = Math.random() * Math.PI * 2;
            let radius = 3.0 + (u * 8.0) + (Math.sin(u * Math.PI) * 4.0);
            let petals = Math.sin(v * 3.0); radius += petals * (u * 3.0);
            let x = radius * Math.cos(v); let z = radius * Math.sin(v); let y = (u * 25.0) - 10.0; 
            x += (Math.random() - 0.5) * 0.5; y += (Math.random() - 0.5) * 0.5; z += (Math.random() - 0.5) * 0.5;
            positions.push(x, y, z); sizes.push(0.5 + Math.random()); randoms.push(Math.random());
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));

        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: { uTime: { value: 0 }, uExplosion: { value: 1.0 } },
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });

        const flower = new THREE.Points(geometry, material);
        scene.add(flower);

        setTimeout(() => { els.loading.style.opacity = 0; }, 1000);


        // --- CONTROL DEL MOUSE AVANZADO ---

        // 1. ZOOM (Rueda del ratón)
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault(); // Evitar scroll de la página
            // deltaY es positivo al bajar la rueda (alejarse), negativo al subir (acercarse)
            camera.position.z += e.deltaY * config.zoomSpeed;
            // Limitar el zoom
            camera.position.z = THREE.MathUtils.clamp(camera.position.z, config.minZ, config.maxZ);
        }, { passive: false });

        // 2. Bloquear menú contextual (Click derecho nativo)
        renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

        // 3. Mouse Down (Detectar qué botón se pulsó)
        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.button === 0) { 
                // --- Click Izquierdo: Formar ---
                state.targetExplosion = 0.0;
                els.debug.innerText = "STATE: FORMING TULIP";
                els.debug.style.color = "#fff";
            } else if (e.button === 2) {
                // --- Click Derecho: Iniciar Rotación ---
                state.isRightDragging = true;
                state.lastMouseX = e.clientX;
                document.body.style.cursor = 'grabbing'; // Feedback visual
            }
        });

        // 4. Mouse Up (Soltar botones)
        window.addEventListener('mouseup', (e) => {
             if (e.button === 0) {
                // --- Soltar Izquierdo: Dispersar ---
                state.targetExplosion = 1.0;
                els.debug.innerText = "STATE: DISPERSED";
                els.debug.style.color = "#ff6699";
            } else if (e.button === 2) {
                // --- Soltar Derecho: Parar Rotación ---
                state.isRightDragging = false;
                document.body.style.cursor = 'crosshair'; // Restaurar cursor
            }
        });

        // 5. Mouse Move (Mover posición O rotar)
        document.addEventListener('mousemove', (e) => {
            if (state.isRightDragging) {
                // --- Lógica de Rotación (Click derecho mantenido) ---
                const deltaX = e.clientX - state.lastMouseX;
                // Ajustar la velocidad de rotación (0.005 es arbitrario)
                state.manualRotationAdd += deltaX * 0.005;
                state.lastMouseX = e.clientX;
            } else {
                // --- Lógica de Posición (Solo si NO se está rotando) ---
                const nX = (e.clientX / window.innerWidth) * 2 - 1;
                const nY = -(e.clientY / window.innerHeight) * 2 + 1;
                // Ajustamos el multiplicador según el zoom actual para que el movimiento se sienta consistente
                const moveScale = camera.position.z * 0.6; 
                state.targetPos.x = nX * moveScale;
                state.targetPos.y = nY * (moveScale * 0.6);
            }
        });


        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            material.uniforms.uTime.value = time;

            // 1. Interpolación de Explosión
            state.currentExplosion += (state.targetExplosion - state.currentExplosion) * 0.05;
            material.uniforms.uExplosion.value = state.currentExplosion;

            // 2. Interpolación de Posición
            state.currentPos.lerp(state.targetPos, config.posLerp);
            flower.position.copy(state.currentPos);

            // 3. Aplicar Rotación
            // Sumamos una rotación automática lenta + la rotación manual acumulada
            flower.rotation.y = (time * 0.05) + state.manualRotationAdd;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

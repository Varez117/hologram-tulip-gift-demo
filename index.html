<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holo-Tulip Interface v3.5 - Fixed Rotation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050005; font-family: 'Consolas', monospace; cursor: crosshair; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 3;
            color: rgba(255, 100, 150, 0.9); pointer-events: none;
            user-select: none;
        }
        h1 { margin: 0; font-size: 1rem; letter-spacing: 2px; border-bottom: 1px solid rgba(255,0,100,0.5); padding-bottom: 5px; display: inline-block;}
        .status { font-size: 0.8rem; margin-top: 8px; }
        .instructions { font-size: 0.7rem; color: #aaa; margin-top: 6px; line-height: 1.4; }
        .key-action { color: #ff0055; font-weight: bold;}

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff0055; font-size: 1.2rem; text-shadow: 0 0 10px #ff0055;
            transition: opacity 0.5s;
        }

        /* Indicador de rotación (aparece al hacer click derecho) */
        #rotate-cursor {
            position: absolute; width: 40px; height: 40px;
            border: 2px dashed rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            z-index: 10;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading">GENERATING FLORA...</div>
    <div id="rotate-cursor"></div>
    <div id="ui-layer">
        <h1>PROJECT: TULIP v3.5</h1>
        <div class="status" id="debug-state">STATE: DISPERSED</div>
        <div class="instructions">
            [MOUSE MOVE] Position<br>
            [<span class="key-action">L-CLICK</span> HOLD] Form Tulip<br>
            [<span class="key-action">R-CLICK</span> DRAG] Rotate 3D<br>
            [<span class="key-action">SCROLL</span>] Zoom In/Out
        </div>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform float uExplosion; 
        attribute float aSize;
        attribute float aRandom;
        varying vec3 vPos;
        varying float vAlpha;

        void main() {
            vec3 pos = position;

            // Dispersión
            float noiseX = sin(uTime * 2.0 + aRandom * 10.0) * 2.0;
            float noiseY = cos(uTime * 1.5 + aRandom * 20.0) * 2.0;
            float noiseZ = sin(uTime * 2.5 + aRandom * 30.0) * 2.0;
            vec3 explosionDir = normalize(pos) * (20.0 + aRandom * 30.0);
            vec3 chaoticPos = pos + explosionDir + vec3(noiseX, noiseY, noiseZ);
            pos = mix(pos, chaoticPos, uExplosion);

            // Pequeña vida interna
            float angle = uTime * 0.05; 
            float s = sin(angle); float c = cos(angle);
            float x = pos.x * c - pos.z * s;
            float z = pos.x * s + pos.z * c;
            pos.x = x; pos.z = z;

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            
            float sizeMod = 1.0 + uExplosion * 2.0; 
            gl_PointSize = (4.0 * aSize * sizeMod) * (60.0 / -mvPosition.z);
            vPos = position; 
            vAlpha = 1.0 - (uExplosion * 0.4);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float uExplosion;
        varying vec3 vPos;
        varying float vAlpha;
        
        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            if(dist > 0.5) discard;

            float height = smoothstep(-10.0, 20.0, vPos.y);
            vec3 darkPink = vec3(0.8, 0.0, 0.4); 
            vec3 lightPink = vec3(1.0, 0.6, 0.8); 
            vec3 white = vec3(1.0, 1.0, 1.0);     
            vec3 color = mix(darkPink, lightPink, height);
            color = mix(color, white, pow(height, 3.0)); 
            if(vPos.y < -8.0) { color = mix(color, vec3(0.0, 0.5, 0.2), 0.7); }

            float extraGlow = uExplosion * 0.15; 
            color += vec3(extraGlow);

            float softness = mix(1.5, 0.5, uExplosion);
            float strength = 1.0 - (dist * 2.0);
            strength = pow(max(0.0, strength), softness);

            gl_FragColor = vec4(color, strength * vAlpha * 0.9);
        }
    </script>

    <script>
        const config = {
            posLerp: 0.08,  
            zoomSpeed: 0.1,
            minZ: 10,
            maxZ: 200,
            rotationSpeed: 0.005
        };

        const state = {
            targetPos: new THREE.Vector3(0, 0, 0),
            currentPos: new THREE.Vector3(0, 0, 0),
            targetExplosion: 1.0, 
            currentExplosion: 1.0,
            
            // Rotación manual
            rotX: 0, 
            rotY: 0,
            isRightDragging: false,
            lastMouseX: 0,
            lastMouseY: 0
        };

        const els = {
            loading: document.getElementById('loading'),
            debug: document.getElementById('debug-state'),
            cursor: document.getElementById('rotate-cursor')
        };

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050005, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- GEOMETRÍA ---
        const geometry = new THREE.BufferGeometry();
        const count = 35000;
        const positions = []; const sizes = []; const randoms = [];

        for(let i=0; i<count; i++) {
            let u = Math.random(); let v = Math.random() * Math.PI * 2;
            let radius = 3.0 + (u * 8.0) + (Math.sin(u * Math.PI) * 4.0);
            let petals = Math.sin(v * 3.0); radius += petals * (u * 3.0);
            let x = radius * Math.cos(v); let z = radius * Math.sin(v); let y = (u * 25.0) - 10.0; 
            x += (Math.random() - 0.5) * 0.5; y += (Math.random() - 0.5) * 0.5; z += (Math.random() - 0.5) * 0.5;
            positions.push(x, y, z); sizes.push(0.5 + Math.random()); randoms.push(Math.random());
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));

        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: { uTime: { value: 0 }, uExplosion: { value: 1.0 } },
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });

        const flower = new THREE.Points(geometry, material);
        scene.add(flower);

        setTimeout(() => { els.loading.style.opacity = 0; }, 1000);

        // --- INPUT HANDLING ---

        // 1. Zoom (Scroll)
        window.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * config.zoomSpeed;
            camera.position.z = THREE.MathUtils.clamp(camera.position.z, config.minZ, config.maxZ);
        });

        // 2. Bloquear menú contextual (FUNDAMENTAL para click derecho)
        window.addEventListener('contextmenu', e => e.preventDefault());

        // 3. Mouse Down
        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Click Izquierdo
                state.targetExplosion = 0.0;
                els.debug.innerText = "STATE: FORMING TULIP";
                els.debug.style.color = "#fff";
            } 
            else if (e.button === 2) { // Click Derecho
                state.isRightDragging = true;
                state.lastMouseX = e.clientX;
                state.lastMouseY = e.clientY;
                
                // UI
                document.body.style.cursor = 'none';
                els.cursor.style.display = 'block';
                els.cursor.style.left = e.clientX + 'px';
                els.cursor.style.top = e.clientY + 'px';
            }
        });

        // 4. Mouse Up
        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                state.targetExplosion = 1.0;
                els.debug.innerText = "STATE: DISPERSED";
                els.debug.style.color = "#ff6699";
            } 
            else if (e.button === 2) {
                state.isRightDragging = false;
                document.body.style.cursor = 'crosshair';
                els.cursor.style.display = 'none';
            }
        });

        // 5. Mouse Move
        window.addEventListener('mousemove', (e) => {
            if (state.isRightDragging) {
                // Mover cursor custom
                els.cursor.style.left = e.clientX + 'px';
                els.cursor.style.top = e.clientY + 'px';

                // Calcular Deltas
                const deltaX = e.clientX - state.lastMouseX;
                const deltaY = e.clientY - state.lastMouseY;

                // Aplicar Rotación
                state.rotY += deltaX * config.rotationSpeed;
                state.rotX += deltaY * config.rotationSpeed;

                // Actualizar referencias
                state.lastMouseX = e.clientX;
                state.lastMouseY = e.clientY;
            } else {
                // Mover Flor (Si no estamos rotando)
                const nX = (e.clientX / window.innerWidth) * 2 - 1;
                const nY = -(e.clientY / window.innerHeight) * 2 + 1;
                
                // Factor de movimiento basado en zoom
                const moveScale = camera.position.z * 0.6; 
                state.targetPos.x = nX * moveScale;
                state.targetPos.y = nY * (moveScale * 0.6);
            }
        });

        // --- ANIMATION ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            material.uniforms.uTime.value = time;

            // Lerps
            state.currentExplosion += (state.targetExplosion - state.currentExplosion) * 0.05;
            material.uniforms.uExplosion.value = state.currentExplosion;

            state.currentPos.lerp(state.targetPos, config.posLerp);
            flower.position.copy(state.currentPos);

            // APLICAR ROTACIÓN MANUAL
            // Usamos rotación euler simple
            flower.rotation.y = state.rotY + (time * 0.05); // Rotación base + manual Y
            flower.rotation.x = state.rotX;                 // Manual X (inclinación)

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
